use std::error::Error;

use proc_macro2::{Literal, TokenStream};
use quote::quote;
use spirv_reflect::types::ReflectDescriptorType;

//macro_rules! p {
//    ($($tokens: tt)*) => {
//        println!("cargo:warning={}", format!($($tokens)*))
//    }
//}

fn descriptor_type_to_tokens(descriptor_type: ReflectDescriptorType) -> TokenStream {
    match descriptor_type {
        ReflectDescriptorType::Undefined => todo!(),
        ReflectDescriptorType::Sampler => todo!(),
        ReflectDescriptorType::CombinedImageSampler => todo!(),
        ReflectDescriptorType::SampledImage => todo!(),
        ReflectDescriptorType::StorageImage => todo!(),
        ReflectDescriptorType::UniformTexelBuffer => todo!(),
        ReflectDescriptorType::StorageTexelBuffer => todo!(),
        ReflectDescriptorType::UniformBuffer => quote! { vk::DescriptorType::UNIFORM_BUFFER },
        ReflectDescriptorType::StorageBuffer => todo!(),
        ReflectDescriptorType::UniformBufferDynamic => todo!(),
        ReflectDescriptorType::StorageBufferDynamic => todo!(),
        ReflectDescriptorType::InputAttachment => todo!(),
        ReflectDescriptorType::AccelerationStructureNV => todo!(),
    }
}

pub fn get_pipeline_template(
    pipeline_struct_name: TokenStream,
    vert_spv_data: &[u8],
    frag_spv_data: &[u8],
) -> Result<TokenStream, Box<dyn Error>> {
    let vert_spv = Literal::byte_string(vert_spv_data);
    let frag_spv = Literal::byte_string(frag_spv_data);

    let module = spirv_reflect::create_shader_module(vert_spv_data)?;

    let mut set_layout_bindings_gen = quote! {};

    let desc_sets = module.enumerate_descriptor_sets(None)?;
    for desc_set in &desc_sets {
        for bind in &desc_set.bindings {
            let binding = bind.binding;
            let descriptor_type = descriptor_type_to_tokens(bind.descriptor_type);
            let count = bind.count;

            set_layout_bindings_gen.extend(quote! {
                vk::DescriptorSetLayoutBinding::builder()
                .binding(#binding)
                .descriptor_type(#descriptor_type)
                .descriptor_count(#count)
                .stage_flags(vk::ShaderStageFlags::VERTEX)
                .build(),
            });
        }
    }

    let rust_code = quote! {
    /// Copyright Â© 2021-2022
    /// Author: Antonio Caggiano <info@antoniocaggiano.eu>
    /// SPDX-License-Identifier: MIT

    /// AUTOGENERATED: please do not delete it unless you want to regenerate it from scratch

    use std::rc::Rc;

    use vkr_core::{
        ash::{self, vk},
        *,
    };

    pub struct #pipeline_struct_name {
        pipeline: vk::Pipeline,
        layout: vk::PipelineLayout,
        set_layout: vk::DescriptorSetLayout,
        device: Rc<ash::Device>,
    }

    impl #pipeline_struct_name {
        /// If I understand it correctly, a descriptor set may have multiple bindings
        fn get_set_layout_bindings() -> Vec<vk::DescriptorSetLayoutBinding> {
            vec![
                #set_layout_bindings_gen
            ]
        }

        pub fn new<V: VertexInput>(
            dev: &mut Dev,
            topology: vk::PrimitiveTopology,
            pass: &Pass,
            width: u32,
            height: u32
        ) -> Self {
            let set_layout_bindings = Self::get_set_layout_bindings();
            let set_layout_info = vk::DescriptorSetLayoutCreateInfo::builder()
                .bindings(&set_layout_bindings);

            let set_layout = unsafe {
                dev.device
                    .create_descriptor_set_layout(&set_layout_info, None)
            }
            .expect("Failed to create Vulkan descriptor set layout");

            let set_layouts = vec![set_layout];

            // Pipeline layout (device, shader reflection?)
            let layout = {
                let create_info = vk::PipelineLayoutCreateInfo::builder()
                    .set_layouts(&set_layouts)
                    .build();
                unsafe { dev.device.create_pipeline_layout(&create_info, None) }
                    .expect("Failed to create Vulkan pipeline layout")
            };

            // Graphics pipeline (shaders, renderpass)
            #[allow(clippy::octal_escapes)]
            let pipeline = {
                let frag_mod = ShaderModule::new(
                    &dev.device,
                    #frag_spv,
                );
                let vert_mod = ShaderModule::new(
                    &dev.device,
                    #vert_spv,
                );

                let entrypoint = std::ffi::CString::new("main").expect("Failed to create main entrypoint");
                let vert_stage = vk::PipelineShaderStageCreateInfo::builder()
                    .stage(vk::ShaderStageFlags::VERTEX)
                    .module(vert_mod.shader)
                    .name(&entrypoint)
                    .build();
                let frag_stage = vk::PipelineShaderStageCreateInfo::builder()
                    .stage(vk::ShaderStageFlags::FRAGMENT)
                    .module(frag_mod.shader)
                    .name(&entrypoint)
                    .build();

                let vertex_bindings = V::get_bindings();
                let vertex_attributes = V::get_attributes();

                let vertex_input = vk::PipelineVertexInputStateCreateInfo::builder()
                    .vertex_attribute_descriptions(&vertex_attributes)
                    .vertex_binding_descriptions(&vertex_bindings)
                    .build();

                let input_assembly = vk::PipelineInputAssemblyStateCreateInfo::builder()
                    .topology(topology)
                    .primitive_restart_enable(false)
                    .build();

                let raster_state = vk::PipelineRasterizationStateCreateInfo::builder()
                    .depth_clamp_enable(false)
                    .rasterizer_discard_enable(false)
                    .polygon_mode(vk::PolygonMode::FILL)
                    .cull_mode(vk::CullModeFlags::NONE)
                    .front_face(vk::FrontFace::COUNTER_CLOCKWISE)
                    .depth_bias_enable(false)
                    .line_width(1.0)
                    .build();

                let viewport = [vk::Viewport::builder()
                    .x(0.0)
                    .y(0.0)
                    .width(width as f32)
                    .height(height as f32)
                    .min_depth(0.0)
                    .max_depth(1.0)
                    .build()];

                let scissor = [vk::Rect2D::builder()
                    .offset(vk::Offset2D::builder().x(0).y(0).build())
                    .extent(vk::Extent2D::builder().width(width).height(height).build())
                    .build()];

                let view_state = vk::PipelineViewportStateCreateInfo::builder()
                    .viewports(&viewport)
                    .scissors(&scissor)
                    .build();

                let multisample_state = vk::PipelineMultisampleStateCreateInfo::builder()
                    .rasterization_samples(vk::SampleCountFlags::TYPE_1)
                    .sample_shading_enable(false)
                    .alpha_to_coverage_enable(false)
                    .alpha_to_one_enable(false)
                    .build();

                let blend_attachment = [vk::PipelineColorBlendAttachmentState::builder()
                    .blend_enable(false)
                    .color_write_mask(vk::ColorComponentFlags::RGBA)
                    .build()];

                let blend_state = vk::PipelineColorBlendStateCreateInfo::builder()
                    .logic_op_enable(false)
                    .attachments(&blend_attachment)
                    .build();

                let stages = [vert_stage, frag_stage];

                let create_info = [vk::GraphicsPipelineCreateInfo::builder()
                    .stages(&stages)
                    .vertex_input_state(&vertex_input)
                    .input_assembly_state(&input_assembly)
                    .viewport_state(&view_state)
                    .rasterization_state(&raster_state)
                    .multisample_state(&multisample_state)
                    .color_blend_state(&blend_state)
                    .render_pass(pass.render)
                    .subpass(0)
                    .layout(layout)
                    .build()];
                let pipelines = unsafe {
                    dev.device
                        .create_graphics_pipelines(vk::PipelineCache::null(), &create_info, None)
                }
                .expect("Failed to create Vulkan graphics pipeline");
                pipelines[0]
            };

            Self {
                pipeline,
                layout,
                set_layout,
                device: Rc::clone(&dev.device),
            }
        }
    }


    impl Drop for #pipeline_struct_name {
        fn drop(&mut self) {
            unsafe {
                self.device
                    .destroy_descriptor_set_layout(self.set_layout, None);
                self.device.destroy_pipeline_layout(self.layout, None);
                self.device.destroy_pipeline(self.pipeline, None);
            }
        }
    }

    impl Pipeline for #pipeline_struct_name {
        fn get_pipeline(&self) -> vk::Pipeline {
            self.pipeline
        }

        fn get_layout(&self) -> vk::PipelineLayout {
            self.layout
        }

        fn get_set_layout(&self) -> vk::DescriptorSetLayout {
            self.set_layout
        }
    }
    };

    Ok(rust_code)
}
